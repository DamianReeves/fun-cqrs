
### Aggregate Behavior

Up to now, we have an Aggregate with a type-safe **Id** and its **Protocol** defining all possible `Commands` and `Evetns`. We still need a way to bind each `Command` to the right operation in the aggregate, let it produces the right `Events` and react to the `Events` accordingly. That all respecting the invariants of the `Lottery` aggregate.

The `Behavior` can be define by means of a declarative **DSL**. It is defined in terms of `Bindings`. A `Binding` describe the different **Command Handlers** and **Event Listerners**.

There are two kinds of **Command Handlers**. Handlers that produce `Events` and handlers that reject commands, also know as 'guard clauses'.

We also make a distinction between `Commands` and `Events` that instantiate an Aggregate (creational `Commands` and `Events`) and those that must be validated against an existing Aggregate instance (update `Commands` and `Events`). This is done by defining the `Bindings` both situations. We have `Bindings` for when the aggregate is `Uninitialized` and for when it's already `Initialized`.


The code below demonstrate how we can build a `Behavior` with the help of the **Behavior DSL**.

[source,scala]
----
import io.funcqrs.behavior.Behavior
import io.funcqrs.dsl.BehaviorDsl.api._
include::../../samples/lottery/src/main/scala/lottery/domain/model/Lottery.scala[tags=lottery-behavior]
----
(ref: https://github.com/strongtyped/fun-cqrs/blob/master/samples/lottery/src/main/scala/lottery/domain/model/Lottery.scala[Lottery.scala, window="_blank"])

<1> `Uninitialized` case defines **Command Handlers** and **Event Listeners** responsible for initialising a `Lottery` aggregate. You can defined as many as you want, but typically there is only one **handler** and one **listener**.
<2> `Initialized` case defines **Command Handlers** and **Event Listeners** responsible for updating an existent Aggregate instance. Note that the current lottery state is made available in scope by pattern machting on `Initialized(lottery)`.
<3> `reject` handlers are **command handlers** that reject a `Command` if a given condition is fulfilled. Note that `reject` handlers are defined using `PartialFunctions` and typically they include a 'guard' per case.
<4> Different **Command Handlers** and **Event Listeners** may be defined.
<5> In some situations, an `Command` may produce more than one `Event`. In that case, we must call `handler.manyEvents` instead an pass a function that returns a `List[Event]`
