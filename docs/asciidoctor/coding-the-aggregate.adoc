
### Coding the Aggregate

The next step is to code the  aggregate itself.

[source,scala]
----
import io.funcqrs.AggregateLike
include::../../samples/lottery/src/main/scala/lottery/domain/model/Lottery.scala[tags=lottery-aggregate]
----
(ref: https://github.com/strongtyped/fun-cqrs/blob/master/samples/lottery/src/main/scala/lottery/domain/model/Lottery.scala[Lottery.scala, window="_blank"])

We define the **Lottery** aggregate by extending the trait `io.funcqrs.AggregateLike`. As a consequence we need to define two type members:

<1> The `Id` which should point to an `AggregateId`. In our case the previously defined `LotteryId`.
<2> The `Protocol` which in our case will point to `LotteryProtocol`. Remember: `LotteryProtocol` is an object. To access its type we must write `LotteryProtocol.type`. `LotteryProtocol` gives us the object singleton instance.

[TIP]
====
The `Lottery` aggregate is a simple case class with methods to 'modify' its state by copying the case class and returning it. It does NOT check the invariants of the aggregate `Lottery` and it doesn't work at the level of `Commands` and `Events`. This is rather a design choice. Nothing forbid us to have `Lottery` reacting direct to `Commands` and `Events` and enforcing its invariants.

For this example we will keep it as a mere data container of the aggregate state. The invariants will be enforced by the `Behavior` we will implement in the next section.
====
