

### Using the Aggregate

Once the `Lottery` aggregate is configured, we request an `AggregateRef` for a `Lottery`. Much like in **Akka** where we can't have access to the Actor itself, in **Fun.CQRS** we don't have direct access to the aggregate. The `Lottery` aggregate will live inside an actor, but instead of working with its `ActorRef` we work with a fully typed `AggregateRef`.

[source,scala]
----
import lottery.domain.model.LotteryId
import lottery.domain.model.LotteryProtocol._

include::../../samples/lottery/src/main/scala/lottery/app/Main.scala[tags=lottery-run]
----
(ref: https://github.com/strongtyped/fun-cqrs/tree/master/samples/lottery/src/main/scala/lottery/app/Main.scala[Main.scala, window="_blank"])

The `lotteryRef` can be used to send commands to the aggregate. Since we are using a Akka backend, all calls return a `Future`. In the event of a successful command, we get back a `Future` with the list of generated events. Otherwise a failed `Future` with an exception.

<1> We request a `AggregateRef` for a `Lottery` using a unique ID.
<2> We send a create command to the `Lottery` aggregate via the `lotteryRef`
<3> We send four AddParticipant commands for four well-known musicians.
<4> Finally we run the **Lottery**
<5> The result is a `Future` holding all `Events` concatenated in a single `Seq` of `Events`.

[TIP]
====
`AggregateRef` is **NOT** an `ActorRef`. However, it does mimic the `ActorRef` API with methods like '?' (ask) and '!' (tell). This is simply because 'tell' and 'ask' are very idiomatic methods for sending `Commands`.

Behind the scenes the `Commands` will be forwarded to the right `Actor` (when using the `AkkaBackend`) holding the Aggregate instance for the passed Id.

When using other backends, the `AggregateRef` may point to other kind of objects, for instance a service or a in-memory data structure.
====
