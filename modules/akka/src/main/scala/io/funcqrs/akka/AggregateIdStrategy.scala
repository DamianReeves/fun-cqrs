package io.funcqrs.akka

import io.funcqrs.{AggregateAliases, AggregateLike}

/**
  * Provide means to configure how an AggregateId should be assigned / generated.
  *
  * Aggregates must have, by definition, unique Ids.
  * Implementors my choose between different strategies:
  *
  * - [[AssignedIdStrategy]] to use whenever an aggregate id is generated externally.
  * (e.g.: user assigned or external system)
  * - [[AutoGeneratedAggregateId]] to use whenever id generation is managed by the application ifself.
  * - [[SingletonAggregateId]] useful for singleton Aggregates with a constant, well-known, id.
  *
  * @tparam A the AggregateType
  */
trait AggregateIdStrategy[A <: AggregateLike] extends AggregateAliases {

  type Aggregate = A

  /** Partial function to transform incoming messages to (Id, Command) tuple */
  type ReceiveCreateCommand = PartialFunction[Any, (Id, Command)]

  /** Handler method receiving the initial command to create an Aggregate
    * This method will not create an Aggregat.
    */
  def seedCommandReceive: ReceiveCreateCommand

}

/**
  * Strategy to use whenever id generation is managed externally.
  * For instance, when user is responsible for choosing an unique id or when it's generated by a
  * external systems.
  *
  * When using this strategy, Aggregates are expected to be initialized with a tuple (Id, Command) where
  * Id is the Aggregate id assigned externally and Command the creational (or seed command)
  * to construct the first Aggregate instance.
  *
  * @tparam A the AggregateType
  */
class AssignedIdStrategy[A <: AggregateLike] extends AggregateIdStrategy[A] {

  /** Receives (Id, Command) tuple and returns it as it. */
  def seedCommandReceive: ReceiveCreateCommand = {
    case (id: Id @unchecked, cmd: Command) => (id, cmd)
  }

  override def toString: String = "AssignedId"
}

object AssignedIdStrategy {
  def apply[A <: AggregateLike]: AssignedIdStrategy[A] = new AssignedIdStrategy[A]
}


/**
  * Strategy to use whenever id generation is managed by application itself.
  *
  * When using this strategy, Aggregates are expected to be initialized with only a Command.
  * No Ids are expected to be passed along with Creational Command.
  *
  * Implementors are required to implement `generateId` method that should return a unique Id each time.
  *
  * @tparam A the AggregateType
  */
trait AutoGeneratedIdStrategy[A <: AggregateLike] extends AggregateIdStrategy[A] {

  /**
    * Generates a unique Aggregate Id
    *
    * @return a unique Aggregate Id
    */
  def generateId(): Id

  /** Receives Command and returns (Id, Command) tuple, where Id is generated by generatedId() methods */
  def seedCommandReceive: ReceiveCreateCommand = {
    case cmd: Command => (generateId(), cmd)
  }

  override def toString: String = "AutoGeneratedId"
}


/**
  * Strategy to use whenever Aggregate is a singleton with a fixed, well-known, Id.
  *
  * When using this strategy, Aggregates are expected to be initialized with only a Command.
  * No Ids are expected to be passed along with Creational Command.
  *
  * Implementors are required to define `id` val.
  *
  * @tparam A the AggregateType
  */
trait SingletonIdStrategy[A <: AggregateLike] extends AggregateIdStrategy[A] {

  val id: Id

  /** Receives a Command and returns (Id, Command) tuple, where Id is fixed */
  def seedCommandReceive: ReceiveCreateCommand = {
    case cmd: Command => (id, cmd)
  }

  override def toString: String = "SingletonId"
}


trait AggregateIdGenerator {
  self: AggregateManager =>

  def idStrategy: AggregateIdStrategy[Aggregate]

  final override def processCreation: Receive = {
    // can `any` be convert to the seed tuple (Id, Command)?
    case any if idStrategy.seedCommandReceive.isDefinedAt(any) =>
      val (id, cmd) = idStrategy.seedCommandReceive(any)
      processAggregateCommand(id, cmd)
  }
}

trait AssignedAggregateId extends AggregateIdGenerator {
  self: AggregateManager =>

  val idStrategy = new AssignedIdStrategy[Aggregate]
}

trait AutoGeneratedAggregateId extends AggregateIdGenerator  {
  autoGen: AggregateManager =>

  def generateId(): Id

  def idStrategy = new AutoGeneratedIdStrategy[Aggregate] {
    def generateId(): Id = autoGen.generateId()
  }
}


/** Provides means to manage a Singleton Aggregate.
  * A Singleton Aggregate has a fixed Id and therefore there must exist only one instance in the whole system.
  */
trait SingletonAggregateId extends AggregateIdGenerator {
  singleton: AggregateManager =>

  val id: Id

  def idStrategy = new SingletonIdStrategy[Aggregate] {
    val id: Id = singleton.id
  }
}

