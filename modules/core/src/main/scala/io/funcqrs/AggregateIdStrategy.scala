package io.funcqrs

/**
 * Provide means to configure how an AggregateId should be assigned / generated.
 *
 * Aggregates must have, by definition, unique Ids.
 * Implementors my choose between different strategies:
 *
 * - [[AssignedIdStrategy]] to use whenever an aggregate id is generated externally.
 * (e.g.: user assigned or external system)
 * - [[GeneratedIdStrategy]] to use whenever id generation is managed by the application itself.
 * - [[SingletonIdStrategy]] useful for singleton Aggregates with a constant, well-known, id.
 *
 * @tparam A the Aggregate type
 */
sealed trait AggregateIdStrategy[A <: AggregateLike] extends AggregateAliases {

  type Aggregate = A

  /** Partial function to transform incoming messages to (Id, Command) tuple */
  type BeforeReceiveCreateCommand = PartialFunction[Any, (Id, Command)]

  /**
   * Handler method receiving the initial command to create an Aggregate
   * This method will not create an Aggregate.
   */
  def beforeReceiveCreateCommand: BeforeReceiveCreateCommand

}

/**
 * Strategy to use whenever id generation is managed externally.
 * For instance, when user is responsible for choosing an unique id or when it's generated by a
 * external system.
 *
 * When using this strategy, Aggregates are expected to be initialized with a tuple (Id, Command) where
 * Id is the Aggregate id assigned externally and Command the creational (or seed command)
 * to construct the first Aggregate instance.
 *
 * @tparam A the Aggregate type
 */
class AssignedIdStrategy[A <: AggregateLike] extends AggregateIdStrategy[A] with AggregateIdExtractors {

  /** Receives (Id, Command) tuple and returns it as is. */
  def beforeReceiveCreateCommand: BeforeReceiveCreateCommand = {
    case (GoodId(id), cmd: Command) => (id, cmd)
  }

  override def toString: String = "AssignedId"
}

object AssignedIdStrategy {
  def apply[A <: AggregateLike]: AssignedIdStrategy[A] = new AssignedIdStrategy[A]
}

trait ManagedIdStrategy[A <: AggregateLike] extends AggregateIdStrategy[A]

/**
 * Strategy to use whenever id generation is managed by application itself.
 *
 * When using this strategy, Aggregates are expected to be initialized with only a Command.
 * No Ids are expected to be passed along with the create Command.
 *
 * Implementors are required to implement `generateId` method that should return a unique Id each time.
 *
 * @tparam A the Aggregate type
 */
trait GeneratedIdStrategy[A <: AggregateLike] extends ManagedIdStrategy[A] {

  /**
   * Generates a unique Aggregate Id
   *
   * @return a unique Aggregate Id
   */
  def generateId(): Id

  /** Receives Command and returns (Id, Command) tuple, where Id is generated by generatedId() methods */
  def beforeReceiveCreateCommand: BeforeReceiveCreateCommand = {
    case cmd: Command => (generateId(), cmd)
  }

  override def toString: String = "GeneratedId"
}

/**
 * Strategy to use whenever the Aggregate is a singleton with a fixed, well-known, Id.
 *
 * When using this strategy, Aggregates are expected to be initialized with only a Command.
 * No Ids are expected to be passed along with the create Command.
 *
 * Implementors are required to define `id` val.
 *
 * @tparam A the Aggregate type
 */
trait SingletonIdStrategy[A <: AggregateLike] extends ManagedIdStrategy[A] {

  val id: Id

  /** Receives a Command and returns (Id, Command) tuple, where Id is fixed */
  def beforeReceiveCreateCommand: BeforeReceiveCreateCommand = {
    case cmd: Command => (id, cmd)
  }

  override def toString: String = "SingletonId"
}